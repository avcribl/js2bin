--- a/src/node.cc
+++ b/src/node.cc
@@ -404,6 +404,14 @@ MaybeLocal<Value> StartExecution(Environment* env, StartExecutionCallback cb) {
     return env->RunSnapshotDeserializeMain();
   }
 
+  // To allow people to extend Node in different ways, this hook allows
+  // one to drop a file lib/_third_party_main.js into the build
+  // directory which will be executed instead of Node's normal loading.
+  if (env->builtin_loader()->Exists("_third_party_main")) {
+    return StartExecution(env, "internal/main/run_third_party_main");
+  }
+
+
   if (env->worker_context() != nullptr) {
     return StartExecution(env, "internal/main/worker_thread");
   }

--- a/lib/internal/streams/end-of-stream.js
+++ b/lib/internal/streams/end-of-stream.js
@@ -65,9 +65,24 @@ function eos(stream, options, callback) {
   }
   validateFunction(callback, 'callback');
   validateAbortSignal(options.signal, 'options.signal');
-
-  AsyncLocalStorage ??= require('async_hooks').AsyncLocalStorage;
-  callback = once(AsyncLocalStorage.bind(callback));
+  
+  // Check if async hooks are enabled by checking if there are any active hooks
+  const { getHookArrays } = require('internal/async_hooks');
+  const [activeHooks] = getHookArrays();
+  const hasActiveHooks = activeHooks.length > 0;
+  
+  if (hasActiveHooks) {
+    // Only apply AsyncLocalStorage binding if async hooks are actually active
+    // This avoids the performance cost of creating AsyncResource instances
+    // when no async context tracking is active
+    AsyncLocalStorage ??= require('async_hooks').AsyncLocalStorage;
+
+    // Only bind if async hooks are active
+    callback = once(AsyncLocalStorage.bind(callback));
+  } else {
+    // No active async hooks, use regular once wrapper
+    callback = once(callback);
+  }
 
   if (isReadableStream(stream) || isWritableStream(stream)) {
     return eosWeb(stream, options, callback);   