diff --git a/deps/v8/src/json/json-stringifier.cc b/deps/v8/src/json/json-stringifier.cc
index 30dfb25623..36ece04a8e 100644
--- a/deps/v8/src/json/json-stringifier.cc
+++ b/deps/v8/src/json/json-stringifier.cc
@@ -124,6 +124,11 @@ class JsonStringifier {
   V8_INLINE bool CurrentPartCanFit(int length) {
     return part_length_ - current_index_ > length;
   }
+  // estimates the maximum number of chars that can fit in the remaining buffer
+  // assumes worst case scenario: each char is convereted in to 6
+  V8_INLINE int MaxCharsThatFit() {
+    return (part_length_ - current_index_) / 6;
+  }
 
   // We make a rough estimate to find out if the current string can be
   // serialized without allocating a new string part. The worst case length of
@@ -253,6 +258,11 @@ class JsonStringifier {
       cursor_ += length;
     }
 
+    V8_INLINE void AppendPacked(uint64_t packed) requires(sizeof(DestChar) == sizeof(uint8_t)) {
+      MemCopy(cursor_, &packed, 8);
+      cursor_ += 8;
+    }
+
    private:
     int* current_index_;
     DestChar* start_;
@@ -326,7 +336,16 @@ class JsonStringifier {
   // Returns whether any escape sequences were used.
   template <typename SrcChar, typename DestChar, bool raw_json>
   V8_INLINE static bool SerializeStringUnchecked_(
-      base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest);
+      base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest,
+      int offset, int endOffset);
+
+  // uses SIMD with a register approach to check if string needs escaping 
+  // much faster perf than memory lookup, falls back to calling 
+  // SerializeStringUnchecked_ when some chars within a block need escaping
+  template <typename SrcChar, typename DestChar, bool raw_json>
+  V8_INLINE static bool SerializeStringUncheckedSWAR_(
+      base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest,
+      int offset, int endOffset);
 
   // Returns whether any escape sequences were used.
   template <typename SrcChar, typename DestChar, bool raw_json>
@@ -342,6 +361,26 @@ class JsonStringifier {
   template <typename Char>
   V8_INLINE static bool DoNotEscape(Char c);
 
+  // inspired by v8 changes, but extended to 64 bit
+  // https://github.com/v8/v8/blob/main/src/json/json-stringifier.cc#L522
+  V8_INLINE static bool NeedsEscape(uint64_t input) {
+    constexpr uint64_t mask_0x20 = 0x2020202020202020ull;
+    constexpr uint64_t mask_0x22 = 0x2222222222222222ull;
+    constexpr uint64_t mask_0x5c = 0x5C5C5C5C5C5C5C5Cull;
+    constexpr uint64_t mask_0x01 = 0x0101010101010101ull;
+    constexpr uint64_t mask_msb  = 0x8080808080808080ull;
+    // Escape control characters (< 0x20).
+    const uint64_t has_lt_0x20 = input - mask_0x20;
+    // Escape double quotation mark (0x22).
+    const uint64_t has_0x22 = (input ^ mask_0x22) - mask_0x01;
+    // Escape backslash (0x5C).
+    const uint64_t has_0x5c = (input ^ mask_0x5c) - mask_0x01;
+    // Chars >= 0x7F don't need escaping.
+    const uint64_t result_mask = ~input & mask_msb;
+    const uint64_t result = ((has_lt_0x20 | has_0x22 | has_0x5c) & result_mask);
+    return result != 0;
+  }
+
   V8_INLINE void NewLine();
   V8_NOINLINE void NewLineOutline();
   V8_INLINE void Indent() { indent_++; }
@@ -1367,14 +1406,68 @@ JsonStringifier::Result JsonStringifier::SerializeJSProxy(
   return SUCCESS;
 }
 
+template <typename SrcChar, typename DestChar, bool raw_json>
+bool JsonStringifier::SerializeStringUncheckedSWAR_(
+    base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest,
+    int offset, int endOffset) {
+  // Assert that base::uc16 character is not truncated down to 8 bit.
+  // The <base::uc16, char> version of this method must not be called.
+  DCHECK(sizeof(DestChar) >= sizeof(SrcChar));
+
+  // don't do SWAR for short strings
+  if (endOffset - offset < 16) {
+    return SerializeStringUnchecked_<SrcChar, DestChar, raw_json>(src, dest, offset, endOffset);
+  }
+
+  int i = offset;
+  bool required_escaping = false;
+  // can only do SWAR iff both src and dest use single byte chars
+  // process the string 8 chars/bytes at a time and use bitwise operations
+  // to check if any of the 8 need escaping. If they don't copy them over
+  // otherwise, fallback on the char-by-char function, for these 8 chars
+  if constexpr ((sizeof(SrcChar) == 1 && sizeof(DestChar) == 1)) {
+    using PackedT = uint64_t;
+    const SrcChar* chars = &src[i];
+    const SrcChar* src_begin = src.begin();
+
+    // get to 8 byte aligned address, process all the bytes before one by one
+    uintptr_t chars_addr = reinterpret_cast<uintptr_t>(chars);
+    uintptr_t addr_offset = chars_addr & 0x07;
+    if(addr_offset != 0) {
+      const int bytesToWrite = 8 - addr_offset;
+      required_escaping = SerializeStringUnchecked_<SrcChar, DestChar, raw_json>(src, dest, i, i+bytesToWrite);
+      i += bytesToWrite;
+    }
+
+    // now chars[i] points to an 8 byte aligned address
+    for (; i < endOffset - 7; i+=8) {
+      PackedT packed = *reinterpret_cast<const PackedT*>(src_begin + i);
+      if (V8_LIKELY(raw_json || !NeedsEscape(packed))) {
+        dest->AppendPacked(packed);
+      } else {
+        required_escaping = true;
+        SerializeStringUnchecked_<SrcChar, DestChar, raw_json>(src, dest, i, i+8);
+      }
+    }
+  }
+
+  // serialize any chars that weren't picked up by packed/swar method above
+  if (i < endOffset){
+    required_escaping = SerializeStringUnchecked_<SrcChar, DestChar, raw_json>(src, dest, i, endOffset) || required_escaping;
+  }
+  return required_escaping;
+}
+
 template <typename SrcChar, typename DestChar, bool raw_json>
 bool JsonStringifier::SerializeStringUnchecked_(
-    base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest) {
+    base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest,
+    int offset, int endOffset) {
   // Assert that base::uc16 character is not truncated down to 8 bit.
   // The <base::uc16, char> version of this method must not be called.
   DCHECK(sizeof(DestChar) >= sizeof(SrcChar));
   bool required_escaping = false;
-  for (int i = 0; i < src.length(); i++) {
+
+  for (int i = offset; i < endOffset; i++) {
     SrcChar c = src[i];
     if (raw_json || DoNotEscape(c)) {
       dest->Append(c);
@@ -1385,7 +1478,7 @@ bool JsonStringifier::SerializeStringUnchecked_(
       required_escaping = true;
       if (c <= 0xDBFF) {
         // The current character is a leading surrogate.
-        if (i + 1 < src.length()) {
+        if (i + 1 < endOffset) {
           // There is a next character.
           SrcChar next = src[i + 1];
           if (base::IsInRange(next, static_cast<SrcChar>(0xDC00),
@@ -1433,73 +1526,39 @@ bool JsonStringifier::SerializeStringUnchecked_(
 template <typename SrcChar, typename DestChar, bool raw_json>
 bool JsonStringifier::SerializeString_(Tagged<String> string,
                                        const DisallowGarbageCollection& no_gc) {
-  int length = string->length();
   bool required_escaping = false;
   if (!raw_json) Append<uint8_t, DestChar>('"');
-  // We might be able to fit the whole escaped string in the current string
-  // part, or we might need to allocate.
-  base::Vector<const SrcChar> vector = string->GetCharVector<SrcChar>(no_gc);
-  if V8_LIKELY (EscapedLengthIfCurrentPartFits(length)) {
-    NoExtendBuilder<DestChar> no_extend(
-        reinterpret_cast<DestChar*>(part_ptr_) + current_index_,
-        &current_index_);
-    required_escaping = SerializeStringUnchecked_<SrcChar, DestChar, raw_json>(
-        vector, &no_extend);
-  } else {
-    for (int i = 0; i < vector.length(); i++) {
-      SrcChar c = vector.at(i);
-      if (raw_json || DoNotEscape(c)) {
-        Append<SrcChar, DestChar>(c);
-      } else if (sizeof(SrcChar) != 1 &&
-                 base::IsInRange(c, static_cast<SrcChar>(0xD800),
-                                 static_cast<SrcChar>(0xDFFF))) {
-        // The current character is a surrogate.
-        required_escaping = true;
-        if (c <= 0xDBFF) {
-          // The current character is a leading surrogate.
-          if (i + 1 < vector.length()) {
-            // There is a next character.
-            SrcChar next = vector.at(i + 1);
-            if (base::IsInRange(next, static_cast<SrcChar>(0xDC00),
-                                static_cast<SrcChar>(0xDFFF))) {
-              // The next character is a trailing surrogate, meaning this is a
-              // surrogate pair.
-              Append<SrcChar, DestChar>(c);
-              Append<SrcChar, DestChar>(next);
-              i++;
-            } else {
-              // The next character is not a trailing surrogate. Thus, the
-              // current character is a lone leading surrogate.
-              AppendCStringLiteral("\\u");
-              char* const hex = DoubleToRadixCString(c, 16);
-              AppendCString(hex);
-              DeleteArray(hex);
-            }
-          } else {
-            // There is no next character. Thus, the current character is a
-            // lone leading surrogate.
-            AppendCStringLiteral("\\u");
-            char* const hex = DoubleToRadixCString(c, 16);
-            AppendCString(hex);
-            DeleteArray(hex);
-          }
-        } else {
-          // The current character is a lone trailing surrogate. (If it had
-          // been preceded by a leading surrogate, we would've ended up in the
-          // other branch earlier on, and the current character would've been
-          // handled as part of the surrogate pair already.)
-          AppendCStringLiteral("\\u");
-          char* const hex = DoubleToRadixCString(c, 16);
-          AppendCString(hex);
-          DeleteArray(hex);
-        }
-      } else {
-        DCHECK_LT(c, 0x60);
-        required_escaping = true;
-        AppendCString(&JsonEscapeTable[c * kJsonEscapeTableEntrySize]);
-      }
+
+  // serialize the contents of the string by in chunks of chars that can fit in
+  // the available buffer, extend the buffer only once full. Note that we need to
+  // be conservative in the number of chars needed, eventhough in real life the
+  // number of chars written out will be the ~ same as the number of chars in the
+  // string. For example, if we have a buffer of 600 bytes available we can only
+  // safely write 100 chars. If we have a string of 200 chars that needs no escaping
+  // then we can safely write it in chunks:
+  // chunk #1 will write 100 chars (remaining 500 bytes, which can fit 83 chars)
+  // chunk #2 will write  83 chars (remaining 417 bytes, which can fit 69 chars)
+  // chunk #3 will write  17 chars and the writing is complete with no checking
+  // nor any unnecessary expansion/copy of the buffer
+  const base::Vector<const SrcChar> vector = string->GetCharVector<SrcChar>(no_gc);
+  int offset = 0;
+  while(offset < vector.length()) {
+    int max_chars = MaxCharsThatFit() - 1; // leave room for trailing "
+    if (max_chars < 1) {
+      Extend();
+      max_chars = MaxCharsThatFit() - 1; // leave room for trailing "
     }
+    // write at most max_chars unchecked and loop again if buffer space is available
+    max_chars = std::min(max_chars, vector.length() - offset);
+    NoExtendBuilder<DestChar> no_extend(
+      reinterpret_cast<DestChar*>(part_ptr_) + current_index_,
+      &current_index_);
+
+    required_escaping = SerializeStringUncheckedSWAR_<SrcChar, DestChar, raw_json>(
+      vector, &no_extend, offset, offset+max_chars) || required_escaping;
+    offset += max_chars;
   }
+
   if (!raw_json) Append<uint8_t, DestChar>('"');
   return required_escaping;
 }
