diff --git a/deps/v8/src/builtins/builtins-definitions.h b/deps/v8/src/builtins/builtins-definitions.h
index cf1ec0d4ad3..c19523f8819 100644
--- a/deps/v8/src/builtins/builtins-definitions.h
+++ b/deps/v8/src/builtins/builtins-definitions.h
@@ -646,6 +646,8 @@ namespace internal {
   CPP(JsonStringify)                                                           \
   CPP(JsonRawJson)                                                             \
   CPP(JsonIsRawJson)                                                           \
+  CPP(JsonUseOriginalStringifyGetter)                                          \
+  CPP(JsonUseOriginalStringifySetter)                                          \
                                                                                \
   /* ICs */                                                                    \
   TFH(LoadIC, LoadWithVector)                                                  \
diff --git a/deps/v8/src/builtins/builtins-json.cc b/deps/v8/src/builtins/builtins-json.cc
index bef2dd47bcd..69911155ab6 100644
--- a/deps/v8/src/builtins/builtins-json.cc
+++ b/deps/v8/src/builtins/builtins-json.cc
@@ -28,6 +28,18 @@ BUILTIN(JsonParse) {
                    : JsonParser<uint16_t>::Parse(isolate, string, reviver));
 }
 
+BUILTIN(JsonUseOriginalStringifySetter) {
+  HandleScope scope(isolate);
+  Handle<Boolean> value = args.at<Boolean>(1);
+  JsonSetUseOriginalStringify(Object::BooleanValue(*value, isolate));
+  return ReadOnlyRoots(isolate).undefined_value();
+}
+
+BUILTIN(JsonUseOriginalStringifyGetter) {
+  HandleScope scope(isolate);
+  return isolate->heap()->ToBoolean(JsonGetUseOriginalStringify());
+}
+
 // ES6 section 24.3.2 JSON.stringify.
 BUILTIN(JsonStringify) {
   HandleScope scope(isolate);
diff --git a/deps/v8/src/init/bootstrapper.cc b/deps/v8/src/init/bootstrapper.cc
index 3b151ea3e86..26e269eccae 100644
--- a/deps/v8/src/init/bootstrapper.cc
+++ b/deps/v8/src/init/bootstrapper.cc
@@ -3546,6 +3546,11 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
                           2, false);
     SimpleInstallFunction(isolate_, json_object, "stringify",
                           Builtin::kJsonStringify, 3, true);
+
+    // setter for the _use_original_stringify property
+    SimpleInstallGetterSetter(isolate_, json_object, "_use_original_stringify",
+                              Builtin::kJsonUseOriginalStringifyGetter,
+                              Builtin::kJsonUseOriginalStringifySetter);
     InstallToStringTag(isolate_, json_object, "JSON");
     native_context()->set_json_object(*json_object);
   }
diff --git a/deps/v8/src/json/json-stringifier.cc b/deps/v8/src/json/json-stringifier.cc
index 30dfb256231..54c7ac44e3b 100644
--- a/deps/v8/src/json/json-stringifier.cc
+++ b/deps/v8/src/json/json-stringifier.cc
@@ -37,7 +37,7 @@ class JsonStringifier {
   V8_WARN_UNUSED_RESULT MaybeHandle<Object> Stringify(Handle<Object> object,
                                                       Handle<Object> replacer,
                                                       Handle<Object> gap);
-
+  static bool _use_original_stringify;
  private:
   enum Result { UNCHANGED, SUCCESS, EXCEPTION, NEED_STACK };
 
@@ -253,6 +253,11 @@ class JsonStringifier {
       cursor_ += length;
     }
 
+    V8_INLINE void AppendPacked(uint64_t packed) requires(sizeof(DestChar) == sizeof(uint8_t)) {
+      MemCopy(cursor_, &packed, 8);
+      cursor_ += 8;
+    }
+
    private:
     int* current_index_;
     DestChar* start_;
@@ -326,13 +331,26 @@ class JsonStringifier {
   // Returns whether any escape sequences were used.
   template <typename SrcChar, typename DestChar, bool raw_json>
   V8_INLINE static bool SerializeStringUnchecked_(
-      base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest);
+      base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest,
+      int offset=-1, int endOffset=-1);
+
+  // uses SIMD with a register approach to check if string needs escaping 
+  // much faster perf than memory lookup, falls back to calling 
+  // SerializeStringUnchecked_ when some chars within a block need escaping
+  template <typename SrcChar, typename DestChar, bool raw_json>
+  V8_INLINE static bool SerializeStringUncheckedSWAR_(
+      base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest,
+      int offset, int endOffset);
 
   // Returns whether any escape sequences were used.
   template <typename SrcChar, typename DestChar, bool raw_json>
-  V8_INLINE bool SerializeString_(Tagged<String> string,
+  V8_INLINE bool SerializeStringOptimized_(Tagged<String> string,
                                   const DisallowGarbageCollection& no_gc);
 
+  // Returns whether any escape sequences were used.
+  template <typename SrcChar, typename DestChar, bool raw_json>
+  V8_INLINE bool SerializeString_(Tagged<String> string,
+                                  const DisallowGarbageCollection& no_gc);
   // Tries to do fast-path serialization for a property key, and returns whether
   // it was successful.
   template <typename DestChar>
@@ -342,6 +360,32 @@ class JsonStringifier {
   template <typename Char>
   V8_INLINE static bool DoNotEscape(Char c);
 
+  // inspired by v8 changes, but extended to 64 bit
+  // https://github.com/v8/v8/blob/main/src/json/json-stringifier.cc#L522
+  V8_INLINE static bool NeedsEscape(uint64_t input) {
+    constexpr uint64_t mask_0x20 = 0x2020202020202020ull;
+    constexpr uint64_t mask_0x22 = 0x2222222222222222ull;
+    constexpr uint64_t mask_0x5c = 0x5C5C5C5C5C5C5C5Cull;
+    constexpr uint64_t mask_0x01 = 0x0101010101010101ull;
+    constexpr uint64_t mask_msb  = 0x8080808080808080ull;
+    // Escape control characters (< 0x20).
+    const uint64_t has_lt_0x20 = input - mask_0x20;
+    // Escape double quotation mark (0x22).
+    const uint64_t has_0x22 = (input ^ mask_0x22) - mask_0x01;
+    // Escape backslash (0x5C).
+    const uint64_t has_0x5c = (input ^ mask_0x5c) - mask_0x01;
+    // Chars >= 0x7F don't need escaping.
+    const uint64_t result_mask = ~input & mask_msb;
+    const uint64_t result = ((has_lt_0x20 | has_0x22 | has_0x5c) & result_mask);
+    return result != 0;
+  }
+
+  // estimates the maximum number of chars that can fit in the remaining buffer
+  // assumes worst case scenario: each char is convereted in to 6
+  V8_INLINE int MaxCharsThatFit() {
+    return (part_length_ - current_index_) / 6;
+  }
+
   V8_INLINE void NewLine();
   V8_NOINLINE void NewLineOutline();
   V8_INLINE void Indent() { indent_++; }
@@ -398,12 +442,20 @@ class JsonStringifier {
   static const bool JsonDoNotEscapeFlagTable[];
 };
 
+bool JsonStringifier::_use_original_stringify = false;
+
 MaybeHandle<Object> JsonStringify(Isolate* isolate, Handle<Object> object,
                                   Handle<Object> replacer, Handle<Object> gap) {
   JsonStringifier stringifier(isolate);
   return stringifier.Stringify(object, replacer, gap);
 }
 
+void JsonSetUseOriginalStringify(bool value) {
+  JsonStringifier::_use_original_stringify = value;
+}
+
+bool JsonGetUseOriginalStringify() { return JsonStringifier::_use_original_stringify; };
+
 // Translation table to escape Latin1 characters.
 // Table entries start at a multiple of 8 and are null-terminated.
 const char* const JsonStringifier::JsonEscapeTable =
@@ -1367,14 +1419,75 @@ JsonStringifier::Result JsonStringifier::SerializeJSProxy(
   return SUCCESS;
 }
 
+template <typename SrcChar, typename DestChar, bool raw_json>
+bool JsonStringifier::SerializeStringUncheckedSWAR_(
+    base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest,
+    int offset, int endOffset) {
+  // Assert that base::uc16 character is not truncated down to 8 bit.
+  // The <base::uc16, char> version of this method must not be called.
+  DCHECK(sizeof(DestChar) >= sizeof(SrcChar));
+
+  // don't do SWAR for short strings
+  if (endOffset - offset < 8) {
+    return SerializeStringUnchecked_<SrcChar, DestChar, raw_json>(src, dest, offset, endOffset);
+  }
+
+  int i = offset;
+  bool required_escaping = false;
+  // can only do SWAR iff both src and dest use single byte chars
+  // process the string 8 chars/bytes at a time and use bitwise operations
+  // to check if any of the 8 need escaping. If they don't copy them over
+  // otherwise, fallback on the char-by-char function, for these 8 chars
+  if constexpr ((sizeof(SrcChar) == 1 && sizeof(DestChar) == 1)) {
+    using PackedT = uint64_t;
+    const SrcChar* chars = &src[i];
+    const SrcChar* src_begin = src.begin();
+
+    // get to 8 byte aligned address, process all the bytes before one by one
+    uintptr_t chars_addr = reinterpret_cast<uintptr_t>(chars);
+    uintptr_t addr_offset = chars_addr & 0x07;
+    if(addr_offset != 0) {
+      const int bytesToWrite = 8 - addr_offset;
+      required_escaping = SerializeStringUnchecked_<SrcChar, DestChar, raw_json>(src, dest, i, i+bytesToWrite);
+      i += bytesToWrite;
+    }
+
+    // now chars[i] points to an 8 byte aligned address
+    for (; i < endOffset - 7; i+=8) {
+      PackedT packed = *reinterpret_cast<const PackedT*>(src_begin + i);
+      if (V8_LIKELY(raw_json || !NeedsEscape(packed))) {
+        dest->AppendPacked(packed);
+      } else {
+        required_escaping = true;
+        SerializeStringUnchecked_<SrcChar, DestChar, raw_json>(src, dest, i, i+8);
+      }
+    }
+  }
+
+  // serialize any chars that weren't picked up by packed/swar method above
+  if (i < endOffset){
+    required_escaping = SerializeStringUnchecked_<SrcChar, DestChar, raw_json>(src, dest, i, endOffset) || required_escaping;
+  }
+  return required_escaping;
+}
+
+
 template <typename SrcChar, typename DestChar, bool raw_json>
 bool JsonStringifier::SerializeStringUnchecked_(
-    base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest) {
+    base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest,
+    int offset, int endOffset) {
   // Assert that base::uc16 character is not truncated down to 8 bit.
   // The <base::uc16, char> version of this method must not be called.
   DCHECK(sizeof(DestChar) >= sizeof(SrcChar));
   bool required_escaping = false;
-  for (int i = 0; i < src.length(); i++) {
+
+  // default behavior ...
+  if(offset == -1 && endOffset == -1) {
+    offset = 0;
+    endOffset = src.length();
+  }
+
+  for (int i = offset; i < endOffset; i++) {
     SrcChar c = src[i];
     if (raw_json || DoNotEscape(c)) {
       dest->Append(c);
@@ -1385,7 +1498,7 @@ bool JsonStringifier::SerializeStringUnchecked_(
       required_escaping = true;
       if (c <= 0xDBFF) {
         // The current character is a leading surrogate.
-        if (i + 1 < src.length()) {
+        if (i + 1 < endOffset) {
           // There is a next character.
           SrcChar next = src[i + 1];
           if (base::IsInRange(next, static_cast<SrcChar>(0xDC00),
@@ -1430,6 +1543,46 @@ bool JsonStringifier::SerializeStringUnchecked_(
   return required_escaping;
 }
 
+template <typename SrcChar, typename DestChar, bool raw_json>
+bool JsonStringifier::SerializeStringOptimized_(Tagged<String> string,
+                                       const DisallowGarbageCollection& no_gc) {
+  bool required_escaping = false;
+  if (!raw_json) Append<uint8_t, DestChar>('"');
+
+  // serialize the contents of the string by in chunks of chars that can fit in
+  // the available buffer, extend the buffer only once full. Note that we need to
+  // be conservative in the number of chars needed, eventhough in real life the
+  // number of chars written out will be the ~ same as the number of chars in the
+  // string. For example, if we have a buffer of 600 bytes available we can only
+  // safely write 100 chars. If we have a string of 200 chars that needs no escaping
+  // then we can safely write it in chunks:
+  // chunk #1 will write 100 chars (remaining 500 bytes, which can fit 83 chars)
+  // chunk #2 will write  83 chars (remaining 417 bytes, which can fit 69 chars)
+  // chunk #3 will write  17 chars and the writing is complete with no checking
+  // nor any unnecessary expansion/copy of the buffer
+  const base::Vector<const SrcChar> vector = string->GetCharVector<SrcChar>(no_gc);
+  int offset = 0;
+  while(offset < vector.length()) {
+    int max_chars = MaxCharsThatFit() - 1; // leave room for trailing "
+    if (max_chars < 1) {
+      Extend();
+      max_chars = MaxCharsThatFit() - 1; // leave room for trailing "
+    }
+    // write at most max_chars unchecked and loop again if buffer space is available
+    max_chars = std::min(max_chars, vector.length() - offset);
+    NoExtendBuilder<DestChar> no_extend(
+      reinterpret_cast<DestChar*>(part_ptr_) + current_index_,
+      &current_index_);
+
+    required_escaping = SerializeStringUncheckedSWAR_<SrcChar, DestChar, raw_json>(
+      vector, &no_extend, offset, offset+max_chars) || required_escaping;
+    offset += max_chars;
+  }
+
+  if (!raw_json) Append<uint8_t, DestChar>('"');
+  return required_escaping;
+}
+
 template <typename SrcChar, typename DestChar, bool raw_json>
 bool JsonStringifier::SerializeString_(Tagged<String> string,
                                        const DisallowGarbageCollection& no_gc) {
@@ -1610,7 +1763,9 @@ bool JsonStringifier::SerializeString(Handle<String> object) {
   auto string = *object;
   if (encoding_ == String::ONE_BYTE_ENCODING) {
     if (String::IsOneByteRepresentationUnderneath(string)) {
-      return SerializeString_<uint8_t, uint8_t, raw_json>(string, no_gc);
+      return  V8_LIKELY(!JsonStringifier::_use_original_stringify)
+                ? SerializeStringOptimized_<uint8_t, uint8_t, raw_json>(string, no_gc)
+                : SerializeString_<uint8_t, uint8_t, raw_json>(string, no_gc);
     } else {
       ChangeEncoding();
     }
@@ -1618,6 +1773,7 @@ bool JsonStringifier::SerializeString(Handle<String> object) {
   DCHECK_EQ(encoding_, String::TWO_BYTE_ENCODING);
   if (String::IsOneByteRepresentationUnderneath(string)) {
     return SerializeString_<uint8_t, base::uc16, raw_json>(string, no_gc);
+
   } else {
     return SerializeString_<base::uc16, base::uc16, raw_json>(string, no_gc);
   }
diff --git a/deps/v8/src/json/json-stringifier.h b/deps/v8/src/json/json-stringifier.h
index 0420cced35a..26a82f2d79b 100644
--- a/deps/v8/src/json/json-stringifier.h
+++ b/deps/v8/src/json/json-stringifier.h
@@ -14,6 +14,9 @@ V8_WARN_UNUSED_RESULT MaybeHandle<Object> JsonStringify(Isolate* isolate,
                                                         Handle<Object> object,
                                                         Handle<Object> replacer,
                                                         Handle<Object> gap);
+
+void JsonSetUseOriginalStringify(bool value);
+bool JsonGetUseOriginalStringify();
 }  // namespace internal
 }  // namespace v8
 
